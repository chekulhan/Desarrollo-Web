
Vamos a crear nuestra primera interacciÃ³n entre el cliente y el servidor.

Recordar, que tenemos una ruta de API en el server.js:

```javascript
// API Route Example
app.get("/api/v1/message", (req, res) => {
  res.json({ message: "Hello from Express!" });
});
```

Construimos un componente para acceder a este ruta:
```jsx
import React, { useEffect, useState } from 'react';

const MessageComponent = () => {
  const [message, setMessage] = useState(null);

  useEffect(() => {
    // Fetch the message from the Express API
    fetch('http://localhost:5000/api/v1/message')
      .then(response => response.json())
      .then(data => {
        setMessage(data.message); // Set the message to state
      })
      .catch(error => {
        console.error('Error fetching the message:', error);
      });
  }, []); // Empty dependency array, so it runs once when the component mounts

  return (
    <div>
      <h1>Message from Express:</h1>
      {message ? <p>{message}</p> : <p>Loading...</p>}
    </div>
  );
};

export default MessageComponent;
```

Y al final, usamos este componente en el programa de ReactJS


```jsx
import './App.css';
import MessageComponent from './components/MessageComponent';

function App() {
  return (
    <div className="App">
        <MessageComponent />

    </div>
  );
}

export default App;


```

# HTTP Protocolo

1. MÃ©todos HTTP
GET: Solicita datos sin modificar el servidor.

POST: EnvÃ­a datos para crear un recurso en el servidor.

PUT: Actualiza un recurso existente en el servidor.

DELETE: Elimina un recurso del servidor.

PATCH: Realiza una actualizaciÃ³n parcial de un recurso.

2. CÃ³digos de Estado (Status Codes)
Los cÃ³digos HTTP en las respuestas indican el estado de la solicitud:

- 1xx: Informacional (ej. 100 Continue)

- 2xx: Ã‰xito (ej. 200 OK)

- 3xx: RedirecciÃ³n (ej. 301 Moved Permanently)

- 4xx: Error del Cliente (ej. 404 Not Found)

- 5xx: Error del Servidor (ej. 500 Internal Server Error)

3. Encabezados HTTP (Headers)
Los encabezados son metadatos que describen la respuesta y controlan el comportamiento de la solicitud y la respuesta. Los encabezados pueden incluir:

Content-Type: Especifica el tipo de contenido (por ejemplo, application/json para JSON, text/html para HTML).

Authorization: Contiene credenciales (como tokens) para la autenticaciÃ³n.

Location: En las respuestas de redirecciÃ³n, muestra la URL a la que se debe redirigir.

Cache-Control: Controla cÃ³mo se deben almacenar en cachÃ© los datos.

Accept: Especifica quÃ© tipo de contenido el cliente estÃ¡ dispuesto a recibir en la respuesta.

4. Cuerpo de la Respuesta (Body)
El cuerpo de la respuesta es donde se encuentran los datos reales que la API envÃ­a de vuelta al cliente. Normalmente, se devuelve en formatos como:

JSON: El formato mÃ¡s comÃºn para datos estructurados.

XML: Otro formato utilizado en algunas APIs.

Texto/HTML: Para pÃ¡ginas web o respuestas de texto.

Ejemplo de cuerpo:
```json
{
  "id": 1,
  "nombre": "Producto-A",
  "precio": 100
}
```

Ejemplo de respuesta de HTTP
```http
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 53
Date: Sat, 06 Apr 2025 12:00:00 GMT
Cache-Control: no-cache

{
  "id": 1,
  "nombre": "Producto-A",
  "precio": 100
}
```

7. CORS (Cross-Origin Resource Sharing)
CORS es un mecanismo que permite o bloquea las solicitudes entre diferentes dominios. Si tu API se consume en el navegador, necesitas entender cÃ³mo gestionar CORS en el servidor para permitir o restringir el acceso a recursos desde dominios externos.


# Restful APIs

https://jsonplaceholder.typicode.com/

https://www.bbvaapimarket.com/es/mundo-api/api-rest-que-es-y-cuales-son-sus-ventajas-en-el-desarrollo-de-proyectos/


https://www.youtube.com/watch?v=JD6VNRdGl98

**ðŸ•°ï¸ Historia de las REST APIs**
ðŸ“… Â¿CuÃ¡ndo y quiÃ©n inventÃ³ REST?
AÃ±o: Alrededor del aÃ±o 2000.

Creador: Roy Fielding, un informÃ¡tico estadounidense.

DÃ³nde: Fielding propuso REST como parte de su tesis doctoral en la Universidad de California, Irvine.

Tesis: Se titulÃ³ "Architectural Styles and the Design of Network-based Software Architectures".


**ðŸ’¡ Â¿QuÃ© significa REST?**
REST = Representational State Transfer.

Es un estilo de arquitectura para diseÃ±ar servicios web ligeros y eficientes.

No es un protocolo ni un estÃ¡ndar, sino un conjunto de principios.

**âš™ï¸ Â¿CÃ³mo funciona REST?**
REST usa el protocolo HTTP, el mismo que usas al navegar pÃ¡ginas web. Los conceptos clave incluyen:

ðŸ” Verbos HTTP (acciones)

| Verbo  | AcciÃ³n comÃºn           | Ejemplo                                         |
|--------|------------------------|-------------------------------------------------|
| GET    | Obtener datos          | `/productos` devuelve la lista                  |
| POST   | Crear un nuevo recurso | `/productos` con datos en el cuerpo             |
| PUT    | Actualizar un recurso  | `/productos/1` actualiza el producto 1          |
| DELETE | Eliminar un recurso    | `/productos/1` elimina el producto 1            |
| PATCH  | Actualizar parcialmente un recurso | `/productos/1` actualiza solo algunos campos del producto 1 |

*El verbo PATCH se usa para hacer actualizaciones parciales de un recurso, a diferencia de PUT, que reemplaza todo el recurso.*

**ðŸ“¦ Recursos**

Todo se trata como un **recurso**, que tiene una **URL**.

**Ejemplo**: `https://api.ejemplo.com/usuarios/123`

---

**ðŸ“„ Respuestas**

- Normalmente en formato **JSON** o **XML**.
- Contienen datos y **cÃ³digos de estado HTTP** (como `200 OK`, `404 Not Found`, etc.).

## ðŸš€ Usos actuales de REST APIs
*ðŸŒ Aplicaciones Web y MÃ³viles*
Las REST APIs son esenciales para el desarrollo de aplicaciones front-end modernas que interactÃºan con servidores backend. Frameworks como ReactJS y Angular suelen hacer peticiones a REST APIs para obtener datos dinÃ¡micos.

Aplicaciones mÃ³viles tambiÃ©n utilizan REST APIs para interactuar con servidores. Los dispositivos mÃ³viles (iOS/Android) hacen solicitudes HTTP (GET, POST, PUT, DELETE) a servidores REST para obtener o modificar informaciÃ³n.

**ðŸ”— Microservicios**
Las architetturas de microservicios estÃ¡n basadas en la comunicaciÃ³n a travÃ©s de APIs, y las REST APIs son una de las formas mÃ¡s comunes de interconectar servicios pequeÃ±os y autÃ³nomos.

Cada microservicio puede tener su propia API REST, lo que permite a los equipos trabajar de forma independiente en cada servicio mientras utilizan estas APIs para comunicarse entre sÃ­.

**ðŸ› ï¸ IntegraciÃ³n con Plataformas Externas**
REST APIs son ampliamente usadas para integrar plataformas externas en aplicaciones, como Twitter, Google, Facebook, etc. Estas plataformas permiten a los desarrolladores interactuar con sus servicios a travÃ©s de REST APIs.

Ejemplo: Conectar una aplicaciÃ³n con la API de Twitter para enviar tuits directamente desde la app.

**ðŸ”„ Internet de las Cosas (IoT)**
IoT es otro campo donde las REST APIs juegan un papel fundamental. Dispositivos inteligentes como termostatos, luces inteligentes y cÃ¡maras se comunican entre sÃ­ o con servicios en la nube a travÃ©s de REST APIs.

**ðŸ¢ Sistemas Empresariales**
Las REST APIs tambiÃ©n se utilizan en sistemas empresariales para integrar diferentes plataformas dentro de una organizaciÃ³n. Por ejemplo, conectar un sistema de inventarios con una plataforma de ventas o integrar aplicaciones de gestiÃ³n de clientes (CRM) con sistemas de facturaciÃ³n.

**ðŸ’» Servicios de Nube**
Las plataformas de nube como AWS, Azure y Google Cloud exponen muchas de sus funcionalidades a travÃ©s de REST APIs. Los desarrolladores utilizan estas APIs para gestionar recursos en la nube, como instancias de servidores, bases de datos, redes, etc.

## ðŸš§ DesafÃ­os y Consideraciones
Aunque REST es simple y ampliamente adoptado, con el tiempo ha surgido una necesidad de soluciones mÃ¡s eficientes para casos complejos. Por ejemplo:

- GraphQL se ha hecho popular como una alternativa a REST debido a su capacidad para permitir consultas mÃ¡s flexibles.

- WebSockets y otras tecnologÃ­as son usadas cuando se requiere comunicaciÃ³n en tiempo real.



## Rest API's con Express

```javascript

// Importar Express
const express = require('express');
const app = express();
const port = 3000;

// Usar JSON para que los POST reciban datos en formato JSON
app.use(express.json());

// SimulaciÃ³n de base de datos
let productos = [
  { id: 1, nombre: 'Producto-A', precio: 100 },
  { id: 2, nombre: 'Producto-B', precio: 150 },
  { id: 3, nombre: 'Producto-C', precio: 200 }
];

// Rutas dinÃ¡micas con parÃ¡metros de URL y versiÃ³n
app.route('/api/v1/productos')
  // MÃ©todo GET: Obtener todos los productos
  .get((req, res) => {
    res.json(productos);
  })
  // MÃ©todo POST: Crear un nuevo producto
  .post((req, res) => {
    const { nombre, precio } = req.body;
    const nuevoProducto = {
      id: productos.length + 1, // Generar un ID Ãºnico
      nombre,
      precio
    };
    productos.push(nuevoProducto);
    res.status(201).json({
      mensaje: 'Producto creado',
      producto: nuevoProducto
    });
  });

// Rutas para productos individuales
app.route('/api/v1/productos/:id')
  // MÃ©todo GET: Obtener informaciÃ³n de un producto
  .get((req, res) => {
    const productoId = req.params.id;
    const producto = productos.find(p => p.id === parseInt(productoId));
    if (!producto) {
      return res.status(404).json({ mensaje: 'Producto no encontrado' });
    }
    res.json(producto);
  })
  // MÃ©todo PUT: Actualizar un producto
  .put((req, res) => {
    const productoId = req.params.id;
    const { nombre, precio } = req.body;
    let producto = productos.find(p => p.id === parseInt(productoId));
    if (!producto) {
      return res.status(404).json({ mensaje: 'Producto no encontrado' });
    }
    producto.nombre = nombre;
    producto.precio = precio;
    res.json({
      mensaje: `Producto con ID: ${productoId} actualizado`,
      producto
    });
  })
  // MÃ©todo DELETE: Eliminar un producto
  .delete((req, res) => {
    const productoId = req.params.id;
    const index = productos.findIndex(p => p.id === parseInt(productoId));
    if (index === -1) {
      return res.status(404).json({ mensaje: 'Producto no encontrado' });
    }
    productos.splice(index, 1); // Eliminar el producto
    res.json({
      mensaje: `Producto con ID: ${productoId} eliminado`
    });
  });

// Iniciar el servidor
app.listen(port, () => {
  console.log(`Servidor corriendo en http://localhost:${port}`);
});

```


## Demo con alumnos - para uso del profesor:

```javascript

const users = [
  {id: 1, nombre: 'Jon', edad: 21},
  {id: 2, nombre: 'Maria', edad: 50}
]

// simulate using a curl GET aswell as with express
// curl -X GET http://localhost:5000/api/v1/users
app.get('/api/v1/users', (req, res) => {
  //res.send('Hello');
  //res.status(200).send('Hola');
  
  //res.json({nombre:'Jon', edad: 20});
  res.json(users);
});

app.get('/api/v1/users/:id', (req, res) => {
  const { id } = req.params;

  res.json({ message: `User details for id: ${id}` });
});



//curl -X POST http://localhost:5000/api/v1/users  -H "Content-Type: application/json" -d '{"nombre": "Mary", "edad":23}'

app.post('/api/v1/users/', async (req, res)=> {
  const data = req.body;
  //const {nombre, edad } = req.body;
  console.log(data);

  res.status(201).json(
    {
      message: 'User creado con exito'
    }

  )
})

// curl -X DELETE http://localhost:5000/api/v1/users/1
app.delete('/api/v1/users/:id', (req, res)=> {
  const {id} = req.params;
  console.log(`deleting ${id}`);
  res.json({message: `User ${id} deleted `});
})
```
