
Vamos a crear nuestra primera interacci√≥n entre el cliente y el servidor.

Recordar, que tenemos una ruta de API en el server.js:

```javascript
// API Route Example
app.get("/api/v1/message", (req, res) => {
  res.json({ message: "Hello from Express!" });
});
```

Construimos un componente para acceder a este ruta:
```jsx
import React, { useEffect, useState } from 'react';

const MessageComponent = () => {
  const [message, setMessage] = useState(null);

  useEffect(() => {
    // Fetch the message from the Express API
    fetch('http://localhost:5000/api/v1/message')
      .then(response => response.json())
      .then(data => {
        setMessage(data.message); // Set the message to state
      })
      .catch(error => {
        console.error('Error fetching the message:', error);
      });
  }, []); // Empty dependency array, so it runs once when the component mounts

  return (
    <div>
      <h1>Message from Express:</h1>
      {message ? <p>{message}</p> : <p>Loading...</p>}
    </div>
  );
};

export default MessageComponent;
```

Y al final, usamos este componente en el programa de ReactJS


```jsx
import './App.css';
import MessageComponent from './components/MessageComponent';

function App() {
  return (
    <div className="App">
        <MessageComponent />

    </div>
  );
}

export default App;


```

# HTTP Protocolo

1. M√©todos HTTP
GET: Solicita datos sin modificar el servidor.

POST: Env√≠a datos para crear un recurso en el servidor.

PUT: Actualiza un recurso existente en el servidor.

DELETE: Elimina un recurso del servidor.

PATCH: Realiza una actualizaci√≥n parcial de un recurso.

2. C√≥digos de Estado (Status Codes)
Los c√≥digos HTTP en las respuestas indican el estado de la solicitud:

- 1xx: Informacional (ej. 100 Continue)

- 2xx: √âxito (ej. 200 OK)

- 3xx: Redirecci√≥n (ej. 301 Moved Permanently)

- 4xx: Error del Cliente (ej. 404 Not Found)

- 5xx: Error del Servidor (ej. 500 Internal Server Error)

3. Encabezados HTTP (Headers)
Los encabezados son metadatos que describen la respuesta y controlan el comportamiento de la solicitud y la respuesta. Los encabezados pueden incluir:

Content-Type: Especifica el tipo de contenido (por ejemplo, application/json para JSON, text/html para HTML).

Authorization: Contiene credenciales (como tokens) para la autenticaci√≥n.

Location: En las respuestas de redirecci√≥n, muestra la URL a la que se debe redirigir.

Cache-Control: Controla c√≥mo se deben almacenar en cach√© los datos.

Accept: Especifica qu√© tipo de contenido el cliente est√° dispuesto a recibir en la respuesta.

4. Cuerpo de la Respuesta (Body)
El cuerpo de la respuesta es donde se encuentran los datos reales que la API env√≠a de vuelta al cliente. Normalmente, se devuelve en formatos como:

JSON: El formato m√°s com√∫n para datos estructurados.

XML: Otro formato utilizado en algunas APIs.

Texto/HTML: Para p√°ginas web o respuestas de texto.

Ejemplo de cuerpo:
```json
{
  "id": 1,
  "nombre": "Producto-A",
  "precio": 100
}
```

Ejemplo de respuesta de HTTP
```http
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 53
Date: Sat, 06 Apr 2025 12:00:00 GMT
Cache-Control: no-cache

{
  "id": 1,
  "nombre": "Producto-A",
  "precio": 100
}
```

7. CORS (Cross-Origin Resource Sharing)
CORS es un mecanismo que permite o bloquea las solicitudes entre diferentes dominios. Si tu API se consume en el navegador, necesitas entender c√≥mo gestionar CORS en el servidor para permitir o restringir el acceso a recursos desde dominios externos.


# Restful APIs

https://jsonplaceholder.typicode.com/

https://www.bbvaapimarket.com/es/mundo-api/api-rest-que-es-y-cuales-son-sus-ventajas-en-el-desarrollo-de-proyectos/


https://www.youtube.com/watch?v=JD6VNRdGl98

**üï∞Ô∏è Historia de las REST APIs**
üìÖ ¬øCu√°ndo y qui√©n invent√≥ REST?
A√±o: Alrededor del a√±o 2000.

Creador: Roy Fielding, un inform√°tico estadounidense.

D√≥nde: Fielding propuso REST como parte de su tesis doctoral en la Universidad de California, Irvine.

Tesis: Se titul√≥ "Architectural Styles and the Design of Network-based Software Architectures".


**üí° ¬øQu√© significa REST?**
REST = Representational State Transfer.

Es un estilo de arquitectura para dise√±ar servicios web ligeros y eficientes.

No es un protocolo ni un est√°ndar, sino un conjunto de principios.

**‚öôÔ∏è ¬øC√≥mo funciona REST?**
REST usa el protocolo HTTP, el mismo que usas al navegar p√°ginas web. Los conceptos clave incluyen:

üîÅ Verbos HTTP (acciones)

| Verbo  | Acci√≥n com√∫n           | Ejemplo                                         |
|--------|------------------------|-------------------------------------------------|
| GET    | Obtener datos          | `/productos` devuelve la lista                  |
| POST   | Crear un nuevo recurso | `/productos` con datos en el cuerpo             |
| PUT    | Actualizar un recurso  | `/productos/1` actualiza el producto 1          |
| DELETE | Eliminar un recurso    | `/productos/1` elimina el producto 1            |
| PATCH  | Actualizar parcialmente un recurso | `/productos/1` actualiza solo algunos campos del producto 1 |

*El verbo PATCH se usa para hacer actualizaciones parciales de un recurso, a diferencia de PUT, que reemplaza todo el recurso.*

**üì¶ Recursos**

Todo se trata como un **recurso**, que tiene una **URL**.

**Ejemplo**: `https://api.ejemplo.com/usuarios/123`

---

**üìÑ Respuestas**

- Normalmente en formato **JSON** o **XML**.
- Contienen datos y **c√≥digos de estado HTTP** (como `200 OK`, `404 Not Found`, etc.).

## üöÄ Usos actuales de REST APIs
*üåê Aplicaciones Web y M√≥viles*
Las REST APIs son esenciales para el desarrollo de aplicaciones front-end modernas que interact√∫an con servidores backend. Frameworks como ReactJS y Angular suelen hacer peticiones a REST APIs para obtener datos din√°micos.

Aplicaciones m√≥viles tambi√©n utilizan REST APIs para interactuar con servidores. Los dispositivos m√≥viles (iOS/Android) hacen solicitudes HTTP (GET, POST, PUT, DELETE) a servidores REST para obtener o modificar informaci√≥n.

**üîó Microservicios**
Las architetturas de microservicios est√°n basadas en la comunicaci√≥n a trav√©s de APIs, y las REST APIs son una de las formas m√°s comunes de interconectar servicios peque√±os y aut√≥nomos.

Cada microservicio puede tener su propia API REST, lo que permite a los equipos trabajar de forma independiente en cada servicio mientras utilizan estas APIs para comunicarse entre s√≠.

**üõ†Ô∏è Integraci√≥n con Plataformas Externas**
REST APIs son ampliamente usadas para integrar plataformas externas en aplicaciones, como Twitter, Google, Facebook, etc. Estas plataformas permiten a los desarrolladores interactuar con sus servicios a trav√©s de REST APIs.

Ejemplo: Conectar una aplicaci√≥n con la API de Twitter para enviar tuits directamente desde la app.

**üîÑ Internet de las Cosas (IoT)**
IoT es otro campo donde las REST APIs juegan un papel fundamental. Dispositivos inteligentes como termostatos, luces inteligentes y c√°maras se comunican entre s√≠ o con servicios en la nube a trav√©s de REST APIs.

**üè¢ Sistemas Empresariales**
Las REST APIs tambi√©n se utilizan en sistemas empresariales para integrar diferentes plataformas dentro de una organizaci√≥n. Por ejemplo, conectar un sistema de inventarios con una plataforma de ventas o integrar aplicaciones de gesti√≥n de clientes (CRM) con sistemas de facturaci√≥n.

**üíª Servicios de Nube**
Las plataformas de nube como AWS, Azure y Google Cloud exponen muchas de sus funcionalidades a trav√©s de REST APIs. Los desarrolladores utilizan estas APIs para gestionar recursos en la nube, como instancias de servidores, bases de datos, redes, etc.

## üöß Desaf√≠os y Consideraciones
Aunque REST es simple y ampliamente adoptado, con el tiempo ha surgido una necesidad de soluciones m√°s eficientes para casos complejos. Por ejemplo:

- GraphQL se ha hecho popular como una alternativa a REST debido a su capacidad para permitir consultas m√°s flexibles.

- WebSockets y otras tecnolog√≠as son usadas cuando se requiere comunicaci√≥n en tiempo real.

## Caracter√≠sticas:
1. üß† **Comunicaci√≥n sin estado (Stateless)**
Qu√© significa:
Cada solicitud del cliente al servidor debe contener toda la informaci√≥n necesaria para procesarla. El servidor no guarda nada de "memoria" entre peticiones.

2. **üîó Interfaz uniforme**
Qu√© significa:
Se deben usar los mismos m√©todos HTTP para interactuar con los recursos: GET, POST, PUT, DELETE. Los recursos se identifican con URLs.

Ejemplo t√©cnico:

- GET /productos ‚Üí obtener todos los productos

- POST /productos ‚Üí crear un nuevo producto

- PUT /productos/1 ‚Üí actualizar producto con ID 1

- DELETE /productos/1 ‚Üí eliminar producto con ID 1

Esto estandariza la comunicaci√≥n.

3. **üìé Arquitectura cliente-servidor**
Qu√© significa:
El cliente y el servidor est√°n completamente separados. El cliente solo necesita saber la URL del recurso. El servidor se encarga de la l√≥gica y datos.

Ejemplo t√©cnico:
Frontend (cliente) hace una petici√≥n a https://api.mitienda.com/productos.
El servidor le responde con JSON:

```json
{
  "nombre": "Zapatillas",
  "precio": 59.99
}
```
El cliente no necesita saber c√≥mo se guarda en la base de datos, solo recibe los datos.


4. **üß± Sistema en capas**
Qu√© significa:
La API puede estar organizada en capas (por ejemplo: cliente ‚Üí proxy ‚Üí servidor de autenticaci√≥n ‚Üí servidor de datos). Cada capa tiene su funci√≥n sin que el cliente lo sepa.

Ejemplo t√©cnico:
Un cliente env√≠a una petici√≥n:

```http
GET /facturas HTTP/1.1
```
Esa petici√≥n puede pasar por:

- Un balanceador de carga

- Un servidor de autenticaci√≥n

- El servidor real de datos

Y el cliente solo ve la respuesta final.


5. **üîÅ HATEOAS (Hypermedia as the Engine of Application State)**
Qu√© significa:
Cada respuesta del servidor debe incluir enlaces (links) que permitan al cliente descubrir acciones relacionadas o navegar a otros recursos.

Ejemplo t√©cnico:

```json
{
  "producto": {
    "id": 10,
    "nombre": "Camiseta",
    "precio": 19.99,
    "links": [
      { "rel": "self", "href": "/productos/10" },
      { "rel": "delete", "href": "/productos/10" },
      { "rel": "update", "href": "/productos/10" }
    ]
  }
}
```
As√≠ el cliente sabe qu√© otras acciones puede realizar.

6. **üì¶ Respuesta cacheable (opcional pero recomendable)**
Qu√© significa:
El servidor puede indicar si la respuesta puede ser guardada en cach√© para evitar repetir la misma consulta y ahorrar recursos.

Ejemplo t√©cnico:

```http
GET /categorias HTTP/1.1
```
Y el servidor responde con:

```http
Cache-Control: max-age=3600
```
Esto indica que la respuesta puede guardarse durante 1 hora.


## Rest API's con Express

```javascript

// Importar Express
const express = require('express');
const app = express();
const port = 3000;

// Usar JSON para que los POST reciban datos en formato JSON
app.use(express.json());

// Simulaci√≥n de base de datos
let productos = [
  { id: 1, nombre: 'Producto-A', precio: 100 },
  { id: 2, nombre: 'Producto-B', precio: 150 },
  { id: 3, nombre: 'Producto-C', precio: 200 }
];

// Rutas din√°micas con par√°metros de URL y versi√≥n
app.route('/api/v1/productos')
  // M√©todo GET: Obtener todos los productos
  .get((req, res) => {
    res.json(productos);
  })
  // M√©todo POST: Crear un nuevo producto
  .post((req, res) => {
    const { nombre, precio } = req.body;
    const nuevoProducto = {
      id: productos.length + 1, // Generar un ID √∫nico
      nombre,
      precio
    };
    productos.push(nuevoProducto);
    res.status(201).json({
      mensaje: 'Producto creado',
      producto: nuevoProducto
    });
  });

// Rutas para productos individuales
app.route('/api/v1/productos/:id')
  // M√©todo GET: Obtener informaci√≥n de un producto
  .get((req, res) => {
    const productoId = req.params.id;
    const producto = productos.find(p => p.id === parseInt(productoId));
    if (!producto) {
      return res.status(404).json({ mensaje: 'Producto no encontrado' });
    }
    res.json(producto);
  })
  // M√©todo PUT: Actualizar un producto
  .put((req, res) => {
    const productoId = req.params.id;
    const { nombre, precio } = req.body;
    let producto = productos.find(p => p.id === parseInt(productoId));
    if (!producto) {
      return res.status(404).json({ mensaje: 'Producto no encontrado' });
    }
    producto.nombre = nombre;
    producto.precio = precio;
    res.json({
      mensaje: `Producto con ID: ${productoId} actualizado`,
      producto
    });
  })
  // M√©todo DELETE: Eliminar un producto
  .delete((req, res) => {
    const productoId = req.params.id;
    const index = productos.findIndex(p => p.id === parseInt(productoId));
    if (index === -1) {
      return res.status(404).json({ mensaje: 'Producto no encontrado' });
    }
    productos.splice(index, 1); // Eliminar el producto
    res.json({
      mensaje: `Producto con ID: ${productoId} eliminado`
    });
  });

// Iniciar el servidor
app.listen(port, () => {
  console.log(`Servidor corriendo en http://localhost:${port}`);
});

```


## Demo con alumnos - para uso del profesor:

```javascript

const users = [
  {id: 1, nombre: 'Jon', edad: 21},
  {id: 2, nombre: 'Maria', edad: 50}
]

// simulate using a curl GET aswell as with express
// curl -X GET http://localhost:5000/api/v1/users
app.get('/api/v1/users', (req, res) => {
  //res.send('Hello');
  //res.status(200).send('Hola');
  
  //res.json({nombre:'Jon', edad: 20});
  res.json(users);
});

app.get('/api/v1/users/:id', (req, res) => {
  const { id } = req.params;

  res.json({ message: `User details for id: ${id}` });
});



//curl -X POST http://localhost:5000/api/v1/users  -H "Content-Type: application/json" -d '{"nombre": "Mary", "edad":23}'

app.post('/api/v1/users/', async (req, res)=> {
  const data = req.body;
  //const {nombre, edad } = req.body;
  console.log(data);

  res.status(201).json(
    {
      message: 'User creado con exito'
    }

  )
})

// curl -X DELETE http://localhost:5000/api/v1/users/1
app.delete('/api/v1/users/:id', (req, res)=> {
  const {id} = req.params;
  console.log(`deleting ${id}`);
  res.json({message: `User ${id} deleted `});
})
```




# Rutas din√°micas
¬øQu√© son las rutas din√°micas?
Las rutas din√°micas en Express permiten capturar valores variables de la URL. Usando par√°metros de ruta (por ejemplo, :id), puedes hacer que la misma ruta funcione para diferentes valores, sin necesidad de definir rutas espec√≠ficas para cada valor.

**Ejemplo:**
Sup√≥n que quieres hacer una aplicaci√≥n de libros, y quieres crear una ruta para mostrar un libro seg√∫n su ID (por ejemplo, /libros/1 para el libro con ID 1, o /libros/2 para el libro con ID 2).

**Paso 1: Definir la Ruta Din√°mica**
En Express, la ruta se define utilizando el par√°metro de ruta en la URL. Vamos a crear una ruta que acepte un ID din√°mico.

```jsx
const libros = [
  { id: 1, titulo: "El Quijote", autor: "Miguel de Cervantes" },
  { id: 2, titulo: "Cien a√±os de soledad", autor: "Gabriel Garc√≠a M√°rquez" },
  { id: 3, titulo: "Don Juan Tenorio", autor: "Tirso de Molina" }
];

// Ruta din√°mica para obtener un libro por su ID
app.get('/libros/:id', (req, res) => {
  const id = parseInt(req.params.id);  // Obtenemos el ID de la URL
  const libro = libros.find(libro => libro.id === id);  // Buscamos el libro con ese ID

  if (libro) {
    res.json(libro);  // Si el libro se encuentra, lo devolvemos en formato JSON
  } else {
    res.status(404).send('Libro no encontrado');  // Si no lo encontramos, devolvemos un error 404
  }
});

```



TO DO:
Understanding req.query vs req.params
It's important to differentiate between query parameters (req.query) and route parameters (req.params). Query parameters are appended to the URL, while route parameters are part of the URL path.
Example:

javascript
Copiar
Editar
// Query: /about?nombre=John
// Route parameter: /about/:id

app.get('/user/:id', (req, res) => {
    console.log(req.params.id);  // Accessing the ID from the route
});




## Respuesta a coches


```jsx
// Endpoint to get a specific coche by its ID
app.get('/api/coches/:id', (req, res) => {
  const cocheId = parseInt(req.params.id);  // Get the coche ID from the URL parameter
  const coche = coches.find(c => c.id === cocheId);  // Find the coche by ID

  if (coche) {
    res.json(coche);  // If found, send the coche data as a response
  } else {
    res.status(404).json({ message: 'Coche no encontrado' });  // If not found, send 404
  }
});
```

Reactjs
```jsx
import React, { useState, useEffect } from 'react';

const ListaCoches = () => {
  const [coches, setCoches] = useState([]);
  const [cargando, setCargando] = useState(true);
  const [error, setError] = useState(null);
  const [cocheIndividual, setCocheIndividual] = useState(null); // State to store the individual coche

  useEffect(() => {
    // Fetch all coches on component mount (or list page)
    fetch('http://localhost:5000/api/coches')
      .then((respuesta) => {
        if (!respuesta.ok) {
          throw new Error('Error al obtener los datos de los coches');
        }
        return respuesta.json();
      })
      .then((data) => {
        setCoches(data);
        setCargando(false);
      })
      .catch((err) => {
        setError(err.message);
        setCargando(false);
      });
  }, []);

  // Function to fetch a single coche by ID
  const fetchCoche = (id) => {
    fetch(`http://localhost:5000/api/coches/${id}`)
      .then((respuesta) => {
        if (!respuesta.ok) {
          throw new Error('Coche no encontrado');
        }
        return respuesta.json();
      })
      .then((data) => {
        setCocheIndividual(data); // Store the individual coche
      })
      .catch((err) => {
        setError(err.message);
      });
  };

  if (cargando) return <div>Cargando...</div>;
  if (error) return <div>{error}</div>;

  return (
    <div>
      <h1>Lista de Coches</h1>

      {/* Display individual coche if it's fetched */}
      {cocheIndividual ? (
        <div>
          <h2>{cocheIndividual.marca} {cocheIndividual.modelo} ({cocheIndividual.a√±o})</h2>
        </div>
      ) : (
        <div>
          <h2>Selecciona un coche para ver m√°s detalles</h2>
        </div>
      )}

      <ul>
        {coches.map((coche) => (
          <li key={coche.id}>
            {coche.marca} {coche.modelo} ({coche.a√±o})
            <button onClick={() => fetchCoche(coche.id)}>Ver Detalles</button>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default ListaCoches;
```


## TO DO
```javascript
const express = require('express');
const app = express();

app.use(express.json()); // to parse JSON request bodies

// Example of chained routes
app.route('/books')
  .get((req, res) => {
    res.send('Get a list of books');
  })
  .post((req, res) => {
    res.send('Add a new book');
  });

app.route('/books/:id')
  .get((req, res) => {
    res.send(`Get details of book with ID ${req.params.id}`);
  })
  .put((req, res) => {
    res.send(`Update book with ID ${req.params.id}`);
  })
  .delete((req, res) => {
    res.send(`Delete book with ID ${req.params.id}`);
  });

app.listen(3000, () => {
  console.log('Server is running on http://localhost:3000');
});
```




